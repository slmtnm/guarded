\chapter{Примеры программ} \label{ch4}

Для эксперементального вывода корректных программ, а также обратного вывода семантики программы
по ее исходному тексту, использованы примеры, приведенные Э. Дейкстрой\cite{Dijkstra} и С.С. Лавровым\cite{Lavrov}.

\section{Факториал числа}
Следующий алгоритм вычисляет факториал числа $N$:
\begin{verbatim}
n, f := N, 1;

{factorial(n) * f == factorial(N) & n >= 1}
do n > 1 -> f, n := f * n, n - 1 od

{f == factorial(N)}
\end{verbatim}

Программа состоит из инициализации переменных $n$ и $f$ и цикла,
умножающего $f$ на числа от 2 до $N$. Инвариант цикла

\begin{equation}
    P = \left( n! \cdot f == N! \wedge n \geq 1 \right)
\end{equation}

обеспечивает истинность постусловия по окончании этого цикла. Действительно,
после окончания работы цикла состояние программы удовлетворяет предикату $P \wedge n <= 1$. Подставляя $P$, получаем
\begin{equation}
n! \cdot f == N! \wedge n \geq 1 \wedge n \leq 1  \vdash n! \cdot f == N! \wedge n == 1 \vdash f == N!
\end{equation}

Выведенное предусловие: 
\begin{equation}
    N \geq 1
\end{equation}

Для функции $factorial$, введенной в постусловии, необходимо показать, что
\begin{equation}
    n == 1 \wedge factorial(N) == f \cdot factorial(n) \vdash f == factorial(N)
\end{equation}

Тогда денотационная семантика программы будет построена, и корректность программы
будет формально доказана. Формула (4.4) выводится очевидным образом.

\section{Максимум двух чисел}
Следующий алгоритм вычисляет максимум из двух чисел $a$ и $b$:
\begin{BVerbatim}
if a > b -> m := a
|  b >= a -> m := b
fi

{(m >= a) & (m >= b) & (m == a || m == b)}
\end{BVerbatim}

Постусловие алгоритма является определением максимума двух чисел; условный оператор преобразует его 
в тождественно истинный предикат. 

\section{Алгоритм Евклида}
Следующая программа вычисляет наибольший общий делитель двух целых чисел $X$ и $Y$:
\begin{BVerbatim}
x, y := X, Y;

{gcd(x, y) == gcd(X, Y) & x >= 0 & y >= 0}
do x > y -> x := x - y
|  x < y -> y := y - x
od

{x == gcd(X, Y)}
\end{BVerbatim}

Чтобы убедиться в том, что из инварианта
\begin{equation}
    P = gcd(x, y) == gcd(X, Y) \wedge x \geq 0 \wedge y \geq 0
\end{equation}
и условия окончания цикла $x == y$ следует постусловие $x == gcd(X, Y)$, необходимо
воспользоваться свойством наибольшего общего делителя:
\begin{equation}
    НОД(x, y) = |x|\text{ при } x = y\text{ и }x, y \geq 0
\end{equation}

Разработанный инструмент для вывода предусловия предлагает вывести эту формулу самостоятельно для 
окончательной верификации алгоритма.

\section{Возведение в степень}
Следующий алгоритм возводит число $X$ в степень $Y$:
\begin{verbatim}
x, y, z := X, Y, 1;

{z * pow(x, y) == pow(X, Y)}
do y != 0 -> y, z := y - 1, z * x od

{z == pow(X, Y)}
\end{verbatim} 

Когда цикл завершает свою работу выполнено условие $y = 0$, поэтому из инварианта цикла непосредственно следует постусловие.

\section{Сортировка четырех чисел}
Необходимо построить алгоритм, который для заданных чисел $Q1, Q2, Q3, Q4$ обеспечивает
в конце своей работы истинность постусловия:
\begin{equation}
    R = (q1, q2, q3, q4 \text{ -- перестановка чисел } Q1, Q2, Q3, Q4) \wedge (q1 \leq q2 \leq q3 \leq q4)
\end{equation}

Поскольку язык не поддерживает оператора проверки того факта, что четыре заданных числа являются
перестановкой других четырех заданных чисел, для этого используются абстрактные функции внутри постусловия
и инвариантов.

Программа принимает следующий вид:
\begin{verbatim}
q1, q2, q3, q4 := Q1, Q2, Q3, Q4;

{isPermutation(q1, q2, q3, q4, Q1, Q2, Q3, Q4) == true}
do q1 > q2 -> q1, q2 := q2, q1
|  q2 > q3 -> q2, q3 := q3, q2
|  q3 > q4 -> q3, q4 := q4, q3
od

{
  isPermutation(q1, q2, q3, q4, Q1, Q2, Q3, Q4) == true &
  q1 <= q2 &
  q2 <= q3 &
  q3 <= q4
}
\end{verbatim} 

Понятно, что инвариант, утверждающий то, что числа $q1, q2, q3, q4$ являются перестановкой чисел $Q1, Q2, Q3, Q4$,
был истинен до цикла, и остается истинным после каждой итерации обмена значениями двух из этих чисел. Из инварианта и
отрицания предохранителей непосредственно следует постусловие алгоритма.

\

\section{Выводы} \label{ch4:conclusion}
В этой главе были рассмотрены несколько простых примеров алгоритмов, записанных на
языке охраняемых команд. Из примеров становится ясно, что наиболее
трудоемким занятием при проектировании корректных программ является нахождение 
инвариантов циклов.

%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы