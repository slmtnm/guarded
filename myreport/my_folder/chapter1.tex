\chapter{Денотационная семантика} \label{ch1}

В этой главе рассматривается денотационный способ задания семантики 
языка программирования путем сопоставления операторам языка математических объектов -- множеств состояний и 
отношений между их характеристическими функциями.

\section{Семантика языка программирования}
Построение семантики языка программирования -- формальное описание смысла, придаваемого его
элементам -- выражениям, предложениям, операторам. Существуют следующие способы определения семантики:
\begin{enumerate}
	\item \textit{Операционный подход} -- смысл программы описывается в терминах реальной или абстрактной
	вычислительной машины, на которой она исполняется.
	\item \textit{Аксиоматический подход} -- вводится формальная теория с набором аксиом, отражающим свойства
	основных конструкций языка, а свойства программ являются теоремами в этой формальной теории.
	\item \textit{Денотационный подход} -- каждым синтаксическим единицам языка сопоставляется математический объект
	в виде совокупности множеств и отношений.
\end{enumerate}

Один и тот же язык может иметь сразу несколько формальных описаний семантики, дополняющих друг друга;
в таком случае семантика языка описывается с разных сторон.

\section{Множество состояний}
Любая программа, предназначенная для выполнения на вычислительном устройстве, оперирует
с определенным набором именованных ячеек памяти -- переменных. 
Совокупность значений переменных на некоторый момент времени называется состоянием программы в этот момент времени. 
Множеством всех возможных состояний программы является прямое произведение областей значений каждой входящей в него переменной. Однако
не все комбинации значений переменных допустимы, поэтому рассматривается не все множество состояний программы, а его 
подмножество допустимых состояний в разных моментах исполнения программы.
Программа может изменять свое состояние как изменением значений имеющихся переменных, так и добавлением новых.
Экспоненциальный рост числа состояний программы в зависимости от количества переменных дает основание 
считать множество возможных состояний практически бесконечным.

Для описания подмножеств множества состояний используется формулы исчисления предикатов. Они содержат
переменные состояния и истинны на некотором подмножестве множества состояний, которое они характеризуют.

Состояние, в котором программа начинает свою работу, называется \textit{начальным состоянием}. Состояние, 
в котором программа остается после завершения своей работы, называется \textit{заключительным состоянием}.

% Таким образом, программе $S$ можно сопоставить функцию на множестве состояний $W$:
% \begin{equation}
% 	Sem(S): W \rightarrow W
% \end{equation}

% Функция $Sem(S)$ называется \textit{семантикой} программы $S$ и отражает связь между начальным и конечным состоянием
% программы.

\section{Предусловие и постусловие}
Рассмотрим некоторую программу $S$ языка охраняемых команд. Предикат $R$ называется \textit{постусловием} программы $S$,
если он истинен на заключительном состоянии программы. Поскольку конечное состояние зависит от начального состояния, то 
и постусловие может быть истинно или ложно в зависимости от начального состояния. Предикат $wp(S, R)$ называется
\textit{слабейшим предусловием} программы $S$ с постусловием $R$, если из любого удовлетворяющего ему начального состояния
программа обязательно завершит свою работу и останется в конечном состоянии, удовлетворяющем предикату $R$. При этом
под термином \textit{слабейшее} понимается то, что предикат $wp(S, R)$ характеризует наибольшее число начальных состояний,
обладающих выше упомянутым свойством. Мы будем рассматривать более широкое множество начальных состояний 
-- таких, для которых завершаемость программы не гарантирована.
Предикат $wlp(S, R)$ называется
\textit{свободным слабейшим предусловием} программы $S$ с постусловием $R$, если из любого удовлетворяющего ему начального состояния,
если программа завершается, то она остается в состоянии, удовлетворяющем $R$. Заметим, что формула 
\begin{equation}
	wlp(S, R) \implies wp(S, R)
\end{equation}
справедлива для всех состояний.

Таким образом каждая программа $S$ однозначно определяет некоторую функцию $wlp(S, R)$,
вычисляющую свободное слабейшее предусловие этой программы по заданному постусловию. Функция $wlp(S, R)$ также
называется преобразователем предикатов для программы $S$.

Вычисление свободного слабейшего предусловия для программы на языке охраняемых команд
является одной из задач настоящей работы.

% \section{Свойства преобразователя предикатов}
% Далее рассмотрены важные свойства преобразователя предикатов $wp(S,R)$.
% \subsection{Правило исключенного чуда}
% Имеет место следующее свойство преобразователя предикатов,
% называемое \textit{правилом исключенного чуда}: для любой программы $S$
% \begin{equation}
% 	wp(S, F) = F
% \end{equation}
% где предикат $F$ -- противоречие.

% Действительно, если $wp(S, F) \neq F$, то найдется такое начальное состояние, удовлетворяющие $wp(S, F)$, такое, что
% программа после своего выполнения останется в состоянии, которой должно удовлетворять $F$, т.е. $F$ должен быть истинен
% в интерпретации конечного состояния программы. Однако такого не может быть, поскольку предикат $F$ ложен в любой 
% интерпретации.

\section{Выводы} \label{ch1:conclusion}
Описана денотационная семантика языка программирования с помощью сопоставления каждой программе
преобразователя предикатов. Получение семантики программы позволяет формально доказать
корректность составленной программы. Однако процесс построения денотационной семантики может быть
затруднительным, как будет видно из следующей главы.

%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы