\chapter{Описание языка} \label{ch2}
В этой главе изложено синтаксическое описание языка охраняемых команд наряду с его семантикой.
Для этого поэтапно вводятся используемые в нем операторы, понятие охраняемой команды, а в приложении
находятся полное синтаксическое описание языка с помощью расширенной формы Бэкуса-Наура (РБНФ) и 
синтаксических диаграмм Вирта.

\section{Оператор <<skip>>}
Оператор \textit{skip} ничего не делает и оставляет программму в том же состоянии, какое было и перед ее
выполнением. Поэтому 
\begin{equation}
	wp(\textit{skip}, R) = R
\end{equation}
\section{Оператор <<reject>>}
Оператор \textit{reject} не может завершиться ни в каком начальном состоянии. Поэтому
\begin{equation}
	wp(\textit{reject}, R) = False
\end{equation}
\section{Оператор присваивания}
Оператор присваивания связывает значение некоторого выражения E с переменной x:
\begin{equation}
	x := E
\end{equation}
Пусть $R$ -- постусловие, а предикат $R_{E\rightarrow x}$ получен из $R$ подстановкой выражения E вместо
всех вхождений переменной x. Тогда 
\begin{equation}
	wp(\textit{x := E}, R) = R_{E\rightarrow x}
\end{equation}
	\subsection{Множественное присваивание}
	Вполне естественным расширением оператора присваивания являвется оператор множественного присваивания:
\begin{equation}
	x_1, x_2 \ldots, x_n := E_1, E_2 \ldots, E_n
\end{equation}
	Он вычисляет значения выражений $E_i, \; i=1,2\ldots, n$ и связывает соответственно переменные $x_1, x_2 \ldots, x_n$ с
	их значениями. Тогда
	\begin{equation}
		wp(x_1, x_2 \ldots, x_n := E_1, E_2 \ldots, E_n, R) = R_{E_1\rightarrow x_1, E_2\rightarrow x_2 \ldots, E_3\rightarrow x_3} 
	\end{equation}
	Предикат $R_{E_1\rightarrow x_1, E_2\rightarrow x_2 \ldots, E_3\rightarrow x_3}$ получается из предиката $R$ подстановкой
	выражений $E_1, E_2 \ldots, E_3$ вместо всех вхождений переменных $x_1, x_2 \ldots, x_n$ соответственно.
	\subsection{Литералы и типы выражений}
	В языке охраняемых команд, по крайней мере в упрощенном его варианте, есть выражений двух видов: численные и логические.
	Вычисление численного выражения производит целое или вещественное число, а вычисление логического выражения
	производит True или False. 
	
	В языке есть следующие литералы:
	\begin{enumerate}
		\item Целые числа, текстовое представление в исходном коде которых описывается регулярным выражением $[1-9][0-9]*$
		\item Вещественные числа, текстовое представление в исходном коде которых описывается регулярным выражением 
		$[1-9][0-9]* '.' [0-9]+$
		\item Логические значения, текстовое представление в исходном коде которых -- \textit{True} или \textit{False}
	\end{enumerate}

\section{Композиция операторов}
До настоящего момента рассматривались только однооператорные программы. Рассмотрим возможность составлять
программы из нескольких операторов. Композиция операторов -- программа вида
$$ S1; S2 $$
При композиция операторов обладает следующей семантикой:
\begin{itemize}
	\item Выполняется оператор S1
	\item Если выполнение оператора S1 завершилось, тогда выполняется оператор S2 с начальным состоянием,
	равным конечному состоянию оператора S1
\end{itemize}

Сопоставим композиции операторов ее преобразователь предикатов. Пусть $R$ -- постусловие композиции операторов $S_1; S_2$.
Это значит, что выполнение оператора $S_2$ должно оставить программу в состоянии, удовлетворющем предикату $R$.
Тогда предусловием оператора $S_2$ будет являться $wp(S_2 ,R)$. Это то состояние, в котором должна находиться программа
после выполнения оператора $S_1$, значит будет являться также и постусловием оператора $S_1$. Соответствующее предусловие
оператора $S_1$ есть $wp(S_1, wp(S_2, R)))$. Итак, получили преобразователь предикатов для композиции операторов:

\begin{equation}
	wp(S_1; S_2, R) = wp(S_1, wp(S_2, R))
\end{equation}

В практическом смысле это означает, что для получения предусловия композиции двух операторов необходимо
последовательно получить предусловия каждого оператора начиная с последнего; этот процесс называется \textit{обратным выводом}.

Несложным образом, определяя трехместную композицию операторов $S_1; S_2; S_3$ как $S_1; (S_2; S_3)$ получим
следующий преобразователь предикатов для нее
\begin{equation}
	wp(S_1; S_2; S_3, R) = wp(S_1, wp(S_2, wp(S_3, R)))
\end{equation}

Аналогичным образом строится преобразователь предикатов для $n$-местной композиции $S_1; S_2; \ldots; S_n$. 

Заметим, что композиция операторов является ассоциативной:
\begin{itemize}
	\item $wp(S_1; (S_2; S_3), R) = wp(S_1, wp(S_2; S_3, R)) = wp(S_1, wp(S_2, wp(S_3, R)))$
	\item $wp((S_1; S_2); S_3, R) = wp(S_1; S_2, wp(S_3, R)) = wp(S_1, wp(S_2, wp(S_3, R)))$
\end{itemize}
\section{Охраняемая команда}

Понятие охраняемой команды является центральным в языке охраняемых команд. 
Охраняемой командой называется конструкция вида
\begin{equation}
	B \rightarrow S
\end{equation}
где $B$ -- логическое выражение, называемое \textit{предохранителем}, а $S$ -- оператор, называемый \text{командой}.

Оператор $S$ может быть выполнен только в том случае, если выражение-предохранитель $B$ имеет истинное значение
на текущем состоянии прогарммы, т.е. на состоянии, в котором программа приступила к выполнению охраняемой команды.

Сама охраняемая команда не является оператором языка, но служит составной часть для структурных операторов
-- \textit{ветвления} и \textit{цикла}.

\section{Условный оператор}
Условным оператором называется оператор, состоящий из одной или нескольких охраняемых команд, 
заключенных в лексемы $if\cdotsfi$:
\begin{equation}
	if B_1 \rightarrow S_1 | B_2 \rightarrow S_2 | \ldots | B_n \rightarrow S_n fi
\end{equation}

Условный оператор обладает следующей семантикой:
\begin{enumerate}
	\item Если ни один из предохранителей $B_1, B_2, \ldots, B_n$ не имеет истинное значение на 
	текущем состоянии программы, то выполнение условного оператора не приводит к завершению программы.
	В этом случае он эквивалентен оператору \textit{reject}.
	\item Пусть предохранители $B_{i_1}, B_{i_2},\ldots, B_{i_m}, 1 \leq i_1, i_2, \ldots, i_m$
\end{enumerate}

\section{Оператор цикла}
\section{Макроподстановки}

\section{Выводы} \label{ch2:conclusion}
Текст заключения ко второй главе. Пример ссылок \cite{Article,Book,Booklet,Conference,Inbook,Incollection,Manual,Mastersthesis,Misc,Phdthesis,Proceedings,Techreport,Unpublished,badiou:briefings}, а также ссылок с указанием страниц, на котором отображены те или иные текстово-графические объекты  \cite[с.~96]{Naidenova2017} или в виде мультицитаты на несколько источников \cites[с.~96]{Naidenova2017}[с.~46]{Ganter1999}. Часть библиографических записей носит иллюстративный характер и не имеет отношения к реальной литературе. 

Короткое имя каждого библиографического источника содержится в специальном файле \verb|my_biblio.bib|, расположенном в папке \verb|my_folder|. Там же находятся исходные данные, которые с помощью программы \texttt{Biber} и стилевого файла \texttt{Biblatex-GOST} \cite{ctan-biblatex-gost} приведены в списке использованных источников согласно ГОСТ 7.0.5-2008.
Многообразные реальные примеры исходных библиографических данных можно посмотреть по ссылке \cite{ctan-biblatex-gost-examples}.

Как правило, ВКР должна состоять из четырех глав. Оставшиеся главы можно создать по образцу первых двух и подключить с помощью команды \verb|\input| к исходному коду ВКР. Далее в приложении \ref{appendix-MikTeX-TexStudio} приведены краткие инструкции запуска исходного кода ВКР \cite{latex-miktex,latex-texstudio}.

В приложении \ref{appendix-extra-examples} приведено подключение некоторых текстово-графических объектов. Они оформляются по приведенным ранее правилам. В качестве номера структурного элемента вместо номера главы используется <<П>> с номером главы. Текстово-графические объекты из приложений не учитываются в реферате.



%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы