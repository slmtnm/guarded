\chapter{Описание языка} \label{ch2}
В этой главе изложено синтаксическое описание языка охраняемых команд наряду с его семантикой.
Для этого поэтапно вводятся используемые в нем операторы и понятие охраняемой команды.
\section{Оператор <<skip>>}
Оператор \textit{skip} ничего не делает и оставляет программму в том же состоянии, какое было и перед ее
выполнением. Поэтому 
\begin{equation}
	wp(\textit{skip}, R) = R
\end{equation}
\section{Оператор <<reject>>}
Оператор \textit{reject} не может завершиться ни в каком начальном состоянии. Поэтому
\begin{equation}
	wp(\textit{reject}, R) = False
\end{equation}
\section{Оператор присваивания}
Оператор присваивания связывает значение некоторого выражения E с переменной x:
\begin{equation}
	x := E
\end{equation}
Пусть $R$ -- постусловие, а предикат $R_{E\rightarrow x}$ получен из $R$ подстановкой выражения E вместо
всех вхождений переменной x. Тогда 
\begin{equation}
	wp(\textit{x := E}, R) = R_{E\rightarrow x}
\end{equation}
	\subsection{Множественное присваивание}
	Вполне естественным расширением оператора присваивания являвется оператор множественного присваивания:
\begin{equation}
	x_1, x_2 \ldots, x_n := E_1, E_2 \ldots, E_n
\end{equation}
	Он вычисляет значения выражений $E_i, \; i=1,2\ldots, n$ и связывает соответственно переменные $x_1, x_2 \ldots, x_n$ с
	их значениями. Тогда
	\begin{equation}
		wp(x_1, x_2 \ldots, x_n := E_1, E_2 \ldots, E_n, R) = R_{E_1\rightarrow x_1, E_2\rightarrow x_2 \ldots, E_3\rightarrow x_3} 
	\end{equation}
	Предикат $R_{E_1\rightarrow x_1, E_2\rightarrow x_2 \ldots, E_3\rightarrow x_3}$ получается из предиката $R$ подстановкой
	выражений $E_1, E_2 \ldots, E_3$ вместо всех вхождений переменных $x_1, x_2 \ldots, x_n$ соответственно.
	\subsection{Литералы и типы выражений}
	В языке охраняемых команд, по крайней мере в упрощенном его варианте, есть выражений двух видов: численные и логические.
	Вычисление численного выражения производит целое или вещественное число, а вычисление логического выражения
	производит True или False. 
	
	В языке есть следующие литералы:
	\begin{enumerate}
		\item Целые числа, текстовое представление в исходном коде которых описывается регулярным выражением $[1-9][0-9]*$
		\item Вещественные числа, текстовое представление в исходном коде которых описывается регулярным выражением 
		$[1-9][0-9]* '.' [0-9]+$
		\item Логические значения, текстовое представление в исходном коде которых -- \textit{True} или \textit{False}
	\end{enumerate}

\section{Композиция операторов}
До настоящего момента рассматривались только однооператорные программы. Рассмотрим возможность составлять
программы из нескольких операторов. Композиция операторов -- программа вида
$$ S1; S2 $$
При композиция операторов обладает следующей семантикой:
\begin{itemize}
	\item Выполняется оператор S1
	\item Если выполнение оператора S1 завершилось, тогда выполняется оператор S2 с начальным состоянием,
	равным конечному состоянию оператора S1
\end{itemize}

Сопоставим композиции операторов ее преобразователь предикатов. Пусть $R$ -- постусловие композиции операторов $S_1; S_2$.
Это значит, что выполнение оператора $S_2$ должно оставить программу в состоянии, удовлетворющем предикату $R$.
Тогда предусловием оператора $S_2$ будет являться $wp(S_2 ,R)$. Это то состояние, в котором должна находиться программа
после выполнения оператора $S_1$, значит будет являться также и постусловием оператора $S_1$. Соответствующее предусловие
оператора $S_1$ есть $wp(S_1, wp(S_2, R)))$. Итак, получили преобразователь предикатов для композиции операторов:

\begin{equation}
	wp(S_1; S_2, R) = wp(S_1, wp(S_2, R))
\end{equation}

В практическом смысле это означает, что для получения предусловия композиции двух операторов необходимо
последовательно получить предусловия каждого оператора начиная с последнего; этот процесс называется \textit{обратным выводом}.

Несложным образом, определяя трехместную композицию операторов $S_1; S_2; S_3$ как $S_1; (S_2; S_3)$ получим
следующий преобразователь предикатов для нее
\begin{equation}
	wp(S_1; S_2; S_3, R) = wp(S_1, wp(S_2, wp(S_3, R)))
\end{equation}

Аналогичным образом строится преобразователь предикатов для $n$-местной композиции $S_1; S_2; \ldots; S_n$. 

Заметим, что композиция операторов является ассоциативной:
\begin{itemize}
	\item $wp(S_1; (S_2; S_3), R) = wp(S_1, wp(S_2; S_3, R)) = wp(S_1, wp(S_2, wp(S_3, R)))$
	\item $wp((S_1; S_2); S_3, R) = wp(S_1; S_2, wp(S_3, R)) = wp(S_1, wp(S_2, wp(S_3, R)))$
\end{itemize}
\section{Охраняемая команда}

Понятие охраняемой команды является центральным в языке охраняемых команд. 
Охраняемой командой называется конструкция вида
\begin{equation}
	B \rightarrow S
\end{equation}
где $B$ -- логическое выражение, называемое \textit{предохранителем}, а $S$ -- оператор, называемый \text{командой}.

Оператор $S$ может быть выполнен только в том случае, если выражение-предохранитель $B$ имеет истинное значение
на текущем состоянии прогарммы, т.е. на состоянии, в котором программа приступила к выполнению охраняемой команды.

Сама охраняемая команда не является оператором языка, но служит составной часть для структурных операторов
-- \textit{ветвления} и \textit{цикла}.

\section{Условный оператор}
\newcommand{\IF}{\textbf{if } B_1 \rightarrow S_1 \text{ | } B_2 \rightarrow S_2 \text{ | } \ldots \text{ | } B_n \rightarrow S_n \textbf{ if}}

Условный оператор определим как оператор, состоящий из одной или нескольких охраняемых команд, 
заключенных в лексемы $if \ldots fi$
\begin{equation}
\IF
\end{equation}

Условный оператор обладает следующей семантикой:
\begin{enumerate}
	\item Если ни один из предохранителей $B_1, B_2, \ldots, B_n$ не имеет истинное значение на 
	текущем состоянии программы, то выполнение условного оператора не приводит к завершению программы.
	В этом случае он эквивалентен оператору \textit{reject}.
	\item Пусть предохранители $B_{i_1}, B_{i_2},\ldots, B_{i_m}$, где $\{i_1, i_2, \ldots, i_m\}$ -- размещение 
	множества $\{1, 2, \ldots, n\}$, имеют истинное значение на начальном состоянии условного оператора.
	Тогда случайным образом выбирается к исполнению оператор из множества $\{S_{i_1}, S_{i_2}, \ldots, S_{i_m}\}$.
\end{enumerate}

Недетерминированности выбора оператора для исполнения не возникает в случае,
когда все предохранители попарно исключают друг друга.
Детерминированный вариант условного оператора выбирает первую команду, чей предохранитель имеет истинное значение.

Построим преобразователь предикатов, соответствующей условному оператору. Пусть задано постусловие $R$ условного 
оператора 
\begin{equation}
	S_{if} = \IF
\end{equation}
Для завершения выполнения оператора необходимо, чтобы хотя бы один предохранитель был истинен на начальном состоянии, откуда приходим к следующему предикату:

\begin{equation}
	B_1 \vee B_2 \vee \ldots \vee B_n
\end{equation}

Помимо этого, каждый оператор, чей предохранитель истинен, должен иметь конечное состояние, удовлетворющее $R$. Поэтому
получаем следующее предусловие для условного оператора:

\begin{equation}
	wp(S_{if}, R) = (B_1 \vee B_2 \vee \ldots \vee B_n) \wedge (\forall i: B_i \Rightarrow wp(S_i, R))
\end{equation}

В практическом смысле это означает, что для нахождения предусловия условного оператора необходимо вычислить предусловия
всех охраняемых команд, и подставить их в формулу (2.13).

\section{Оператор цикла}
\newcommand{\DO}{\textbf{do } B_1 \rightarrow S_1 \text{ | } B_2 \rightarrow S_2 \text{ | } \ldots \text{ | } B_n \rightarrow S_n \textbf{ od}}
Оператор цикла определим как оператор, состоящий из одной или нескольких охраняемых команд, заключенных между лексемами $do\ldots od$:
\begin{equation}
	\DO
\end{equation}

Семантика оператора цикла следующая:
\begin{enumerate}
	\item Если ни один из предохранителей $B_1, B_2, \ldots, B_n$ не имеет истинного значения на текущем состоянии программы, 
	то оператор цикла завершает свою работу
	\item Пусть предохранители $B_{i_1}, B_{i_2},\ldots, B_{i_m}$, где $\{i_1, i_2, \ldots, i_m\}$ -- размещение 
	множества $\{1, 2, \ldots, n\}$, имеют истинное значение на начальном состоянии оператора цикла.
	Тогда случайным образом выбирается к исполнению оператор из множества $\{S_{i_1}, S_{i_2}, \ldots, S_{i_m}\}$.
	Затем заново вычисляются истинностные значения всех предохранителей на новом состоянии программы,
	полученном после выполнения одной из охраняемых команд, и выполняется переход к предыдущему шагу.
\end{enumerate}

Соответствующий преобразователь предикатов определяется следующим образом выражается через преобразователь предикатов
для условного оператора, имеющего те же охраняемые команды.

Пусть
\begin{equation}
	wp(S_{do}, R) = \DO
\end{equation}
\begin{equation}
	wp(S_{if}, R) = \IF
\end{equation}

Дадим рекурсивное определение предикатов $H_0(R), \; k = 1, 2\ldots$:
\begin{equation}
	H_0(R) = R \wedge \neg (\exists j: 1 \leq j \leq n: B_j)
\end{equation}
\item Для любого $k > 0$:
\begin{equation}
	H_k(R) = wp(S_{if}, H_{k-1}(R)) \vee H_0(R)
\end{equation}

Тогда преобразователь предикатов для $S_{do}$ определяется как
\begin{equation}
	wp(S_{do}, R) = (\exists k: k \geq 0: H_k(R))
\end{equation}

Предикат $H_k(R)$ ялвяется слабейшим предусловием того, что оператор цикла $S_{do}$ завершится не более
чем за $k$ выборок.

Формула (2.17) означает предусловие, в котором должна находиться программа в случае, если все предохранители ложны.
В этом случае не производится вычисление ни одной охраняемой команды.

Формула (2.18) при $k>0$ имеет два дизъюнктивных слагаемых: либо все предохранители оказались ложны, и это произошло меньше чем за $k$ выборок,
либо есть истинные предохранители, и тогда выполняются действия, семантически эквивалентные однократному оператору $S_{if}$. После этой выборки
программа должна оказаться в таком состоянии, чтобы далее потребовалось не более чем $k - 1$ выборка охраняемой команды для
завершения цикла в состоянии, удовлетворющем $R$.

Формальное определение семантики оператора цикла не имеет большого практического смысла, так как
заблаговременно определить количество итераций цикла $k$ представляется невозможным. 

\subsection{Инвариант цикла}
Если удается найти предикат, не изменяющий свою истинность после выполнения оператора $S_{if}$, и при этом
истинный до начала исполнения оператора $S_{do}$, более того достаточно сильный, чтобы
из него следовало постусловие цикла, то преобразователь предикатов для оператора цикла
можно определить гораздо проще, чем в формуле (2.19). Данные рассуждения следуют из \textit{основной теоремы для оператора цикла} (цитата).

\textbf{Теорема}. Пусть оператор цикла $S_{do}$ и предикат $P$ таковы, что предикат
\begin{equation}
	(P \wedge (\exists i: 1 \leq i \leq n: B_i)) \Rightarrow wp(S_{if}, P)
\end{equation}
справедлив для всех состояний. Тогда для оператора цикла $S_{do}$ предикат
\begin{equation}
	(P \wedge wp(S_{do}, T)) \Rightarrow wp(S_{do}, P \wedge \neg (\exsits i: 1 \leq i \leq n: B_j))
\end{equation}
где $T$ -- тавтология, также справедлив для всех состояний.

Предикат $w(S_{do}, T)$ характеризует начальные состояний, для которых оператор цикла завершает свою работу.
Основная теорема для оператора цикла позволяет считать предикат $P \wedge wp(S_{do}, T)$ предусловием цикла, если:
\begin{enumerate}
	\item Удается доказать, что цикл завершается. Другими словами, удается найти предикат $wp(S_{do}, T)$
	\item Предикат $P \wedge \neg (\exsits i: 1 \leq i \leq n: B_j)$ истинен для всех состояний
\end{enumerate}

\section{Макроподстановки}
Многие алгоритмы удобно строить разбивая исходную задачу на подзадачи, а их, в свою очередь
на еще более маленькие подзадачи и так далее. Такой метод проектирования алгоритмов и программного
обеспечения в целом носит название \textit{метода пошагового уточнения}. Для
того, чтобы использовать этот метод, удобным инструментом внутри языка являются макросы.

В рассматриваемом языке охраняемых команд введено понятие макро-функций -- макросов с параметрами.
Такие макросы могут быть объявлены и определены отдельно от программы, а затем встроены в место ее вызова. Макросы
являются синтаксическими и работают с абстрактным синтаксисом, в отличие, например, от макросов языка Си.
Вызов макроса с параметрами является отдельным оператором языка. 

Например макрос, складывающий два числа $x$ и $y$ объявляется следующим образом:

\begin{verbatim}
add(x,y) :=
    z := x + y 
\end{verbatim}

Оператор вызова макроса:

\begin{verbatim}
x := 2; add(x, y)
\end{verbatim}

\section{Задание постусловий и инвариантов}
Поскольку исследуется вывод предусловия исходя из заданного пользователем постусловие, необходима
возможность его указывать либо вне программного текста, либо внутри него. Было решено
встроить постусловие и инварианты цикла в сам программный текст. Таким образом,
вместе с операторами программы, которые будут исполнены при интерпретации, содержится и
спецификация алгоритма. 

Постусловие объявляется как логическое выражение, содержащее переменные программы. В этом случае программа
принимает вид:
\begin{verbatim}
	S1; S2; ...; Sn {<постусловие>}
\end{verbatim}

Каждый оператор цикла содержит свой инвариант, который также является логическим выражением:
\begin{verbatim}
	{<инвариант>} do ... od
\end{verbatim}

\section{Выводы} \label{ch2:conclusion}
Итак, описаны операторы языка охраняемых команд и определена их семантика путем
сопоставления им некоторого преобразователя предикатов -- функционального отношения на множестве предикатов.
В приложении ??? приведено описание конкретного синтаксиса языка в расширенной форме Бэкуса-Наура и
иллюстрированы синтаксичекие диаграммы Вирта.
%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы