\chapter{Описание языка} \label{ch2}
В этой главе изложено синтаксическое описание и семантика языка охраняемых команд.
Поэтапно определяются используемые в нем операторы и понятие охраняемой команды.
В следующих определениях предикатами $T$ и $F$ обозначены предикаты,
истинные и ложные соответственно на всех возможных состояниях программы.

\section{Оператор <<skip>>}
Оператор \textit{skip} обладает следующей семантикой: 
\begin{equation}
	wp(\textit{skip}, R) = R
\end{equation}

Он оставляет программму в том же состоянии, какое было и перед ее
выполнением. Иначе, он не производит никаких вычислений и не оказывает эффекта на состояние программы.

\section{Оператор <<abort>>}
Другим очевидным примером семантики является
\begin{equation}
	wp(\textit{abort}, R) = F
\end{equation}

Оператор, обладающей такой семантикой, называется оператором \textit{abort}.
Он не может привести к успешному завершению ни при каком начальном состоянии.

Заметим, что не может быть оператора, обладающего семантикой:
\begin{equation}
	wp(\textit{abort}, R) = T
\end{equation}
Действительно, если бы такой оператор существовал, то из состояния, удовлетворяющего предикату $F$,
он бы должен был завершиться в состоянии, удовлетворющем предикату $T$. Однако не существует
начального состояния, удовлетворяющего $F$.

\section{Оператор присваивания}
\textit{Оператор присваивания} связывает значение некоторого выражения E с переменной x и записывается в виде:
\begin{equation}
	x := E
\end{equation}
Пусть $R$ -- постусловие, а предикат $R_{E\rightarrow x}$ получен из $R$ подстановкой выражения E вместо
всех вхождений переменной x. Тогда 
\begin{equation}
	wp(\textit{x := E}, R) = R_{E\rightarrow x}
\end{equation}
\subsection{Множественное присваивание}
	Естественным расширением оператора присваивания является \textit{оператор множественного присваивания},
	который записывается в виде:
\begin{equation}
	x_1, x_2 \ldots, x_n := E_1, E_2 \ldots, E_n
\end{equation}
	Он вычисляет значения выражений $E_i, \; i=1,2\ldots, n$ и связывает соответственно переменные $x_1, x_2 \ldots, x_n$ с
	их значениями. Тогда
	\begin{equation}
		wp(x_1, x_2 \ldots, x_n := E_1, E_2 \ldots, E_n, R) = R_{E_1\rightarrow x_1, E_2\rightarrow x_2 \ldots, E_3\rightarrow x_3} 
	\end{equation}
	Предикат $R_{E_1\rightarrow x_1, E_2\rightarrow x_2 \ldots, E_3\rightarrow x_3}$ получается из предиката $R$ подстановкой
	выражений $E_1, E_2 \ldots, E_3$ вместо всех вхождений переменных $x_1, x_2 \ldots, x_n$ соответственно.

\subsection{Литералы и типы выражений}
	В разработанном языке охраняемых команд есть выражения двух типов: численные и логические.
	Вычисление численного выражения производит вещественное число, а вычисление логического выражения
	производит истинностное значение: \textit{True} или \textit{False}.
	Численное выражение является:
	\begin{enumerate}
		\item Либо целочисленным или вещественным литералом;
		\item Либо идентификатором переменной;
		\item Либо суммой, разностью, произведением или частным двух численных выражений;
	\end{enumerate}
	
	Логическое выражение является:
	\begin{enumerate}
		\item Либо литералом True или False;
		\item Либо конъюнкцией, дизъюнкцией, отрицанием, импликацией логических выражений;
		\item Либо сравнением двух численных выражений;
	\end{enumerate}

	Для любых выражений допустимо заключать подвыражения в скобки для повышения приоритета вычислений
	операндов выражения.

\section{Композиция операторов}
До этого момента рассматривались только однооператорные программы. Рассмотрим возможность составлять
программы из нескольких операторов. Композиция операторов -- программа вида
$$ S1; S2 $$
При композиции операторов программа обладает следующей семантикой:
\begin{itemize}
	\item Выполняется оператор S1
	\item Если выполнение оператора S1 завершилось, то выполняется оператор S2 с начальным состоянием,
	равным конечному состоянию оператора S1
\end{itemize}

Сопоставим композиции операторов ее преобразователь предикатов. Пусть $R$ -- постусловие композиции операторов $S_1; S_2$.
Это значит, что выполнение оператора $S_2$ должно оставить программу в состоянии, удовлетворющем предикату $R$.
Тогда предусловием оператора $S_2$ будет являться $wp(S_2 ,R)$. Это то состояние, в котором должна находиться программа
после выполнения оператора $S_1$. Соответствующее предусловие
оператора $S_1$ есть $wp(S_1, wp(S_2, R)))$. Итак, получили преобразователь предикатов для композиции операторов:

\begin{equation}
	wp(S_1; S_2, R) = wp(S_1, wp(S_2, R))
\end{equation}

В практическом смысле это означает, что для получения предусловия композиции двух операторов необходимо
последовательно получить предусловия каждого оператора начиная с последнего; этот процесс называется \textit{обратным выводом}.

Несложным образом, определяя трехместную композицию операторов $S_1; S_2; S_3$ как $S_1; (S_2; S_3)$ получим
следующий преобразователь предикатов для нее
\begin{equation}
	wp(S_1; S_2; S_3, R) = wp(S_1, wp(S_2, wp(S_3, R)))
\end{equation}

Аналогичным образом строится преобразователь предикатов для $n$-местной композиции $S_1; S_2; \ldots; S_n$. 

Заметим, что композиция операторов является ассоциативной:
\begin{itemize}
	\item $wp(S_1; (S_2; S_3), R) = wp(S_1, wp(S_2; S_3, R)) = wp(S_1, wp(S_2, wp(S_3, R)))$
	\item $wp((S_1; S_2); S_3, R) = wp(S_1; S_2, wp(S_3, R)) = wp(S_1, wp(S_2, wp(S_3, R)))$
\end{itemize}
\section{Охраняемая команда}

Понятие охраняемой команды является центральным в языке охраняемых команд. 
Охраняемой командой называется конструкция вида
\begin{equation}
	B \rightarrow S
\end{equation}
где $B$ -- логическое выражение, называемое \textit{предохранителем} или \textit{сторожевым условием}, 
а $S$ -- оператор или композиция операторов.

Команда $S$ может быть выполнена только в том случае, если логическое выражение-предохранитель $B$ имеет истинное значение
на текущем состоянии программы, т.е. на состоянии, в котором программа приступила к выполнению охраняемой команды.

Сама охраняемая команда не является оператором языка, но служит составной часть для \textit{условного оператора} или оператора \textit{цикла}.

\section{Условный оператор}
\newcommand{\IF}{\textbf{if } B_1 \rightarrow S_1 \text{ | } B_2 \rightarrow S_2 \text{ | } \ldots \text{ | } B_n \rightarrow S_n \textbf{ if}}

Условный оператор записывается в виде одной или нескольких охраняемых команд, 
заключенных в лексемы if и fi:
\begin{equation}
\IF
\end{equation}

Условный оператор обладает следующей семантикой:
\begin{enumerate}
	\item Если ни один из предохранителей $B_1, B_2, \ldots, B_n$ не имеет истинное значение на 
	текущем состоянии программы, то выполнение условного оператора не приводит к завершению программы.
	В этом случае он эквивалентен оператору \textit{abort}.
	\item Пусть предохранители $B_{i_1}, B_{i_2},\ldots, B_{i_m}$, где $\{i_1, i_2, \ldots, i_m\}$ -- размещение 
	множества $\{1, 2, \ldots, n\}$, имеют истинное значение на начальном состоянии условного оператора.
	Тогда случайным образом выбирается к исполнению оператор из множества $\{S_{i_1}, S_{i_2}, \ldots, S_{i_m}\}$.
\end{enumerate}

Таким образом, условный оператор является \textit{недетерминированным}: его выполнение с одним и тем же начальным состоянием
может приводить к различным конечным состояниям.
Недетерминированности выбора охраняемой команды для исполнения не возникает в случае, когда все предохранители попарно исключают друг друга.
Детерминированный вариант условного оператора выбирает первую команду, чей предохранитель имеет истинное значение.

Построим преобразователь предикатов, соответствующей условному оператору. Пусть задано постусловие $R$ условного 
оператора 
\begin{equation}
	S_{if} = \IF
\end{equation}
Для завершения выполнения оператора необходимо, чтобы хотя бы один предохранитель был истинен на начальном состоянии, откуда приходим к следующему предикату:

\begin{equation}
	B_1 \vee B_2 \vee \ldots \vee B_n
\end{equation}

Помимо этого, у каждой команды, у который предохранитель истинен, конечное состояние должно удовлетворять $R$. Поэтому
получаем следующее предусловие для условного оператора:

\begin{equation}
	wp(S_{if}, R) = (B_1 \vee B_2 \vee \ldots \vee B_n) \wedge (\forall i: B_i \Rightarrow wp(S_i, R))
\end{equation}

В практическом смысле это означает, что для нахождения предусловия условного оператора необходимо вычислить предусловия
всех охраняемых команд, и подставить их в формулу (2.14).

\section{Оператор цикла}
\newcommand{\DO}{\textbf{do } B_1 \rightarrow S_1 \text{ | } B_2 \rightarrow S_2 \text{ | } \ldots \text{ | } B_n \rightarrow S_n \textbf{ od}}
Оператор цикла записывается в виде одной или нескольких охраняемых команд, заключенных между лексемами $do\ldots od$:
\begin{equation}
	\DO
\end{equation}

Семантика оператора цикла следующая:
\begin{enumerate}
	\item Если ни один из предохранителей $B_1, B_2, \ldots, B_n$ не имеет истинного значения на текущем состоянии программы, 
	то оператор цикла завершает свою работу
	\item Пусть предохранители $B_{i_1}, B_{i_2},\ldots, B_{i_m}$, где $\{i_1, i_2, \ldots, i_m\}$ -- размещение 
	множества $\{1, 2, \ldots, n\}$, имеют истинное значение на начальном состоянии оператора цикла.
	Тогда случайным образом выбирается к исполнению оператор из множества $\{S_{i_1}, S_{i_2}, \ldots, S_{i_m}\}$.
	Затем заново вычисляются истинностные значения всех предохранителей на новом состоянии программы,
	полученном после выполнения одной из охраняемых команд, и выполняется переход к предыдущему шагу.
\end{enumerate}

Соответствующий преобразователь предикатов выражается через преобразователь предикатов
для условного оператора, имеющего те же охраняемые команды.

Пусть
\begin{equation}
	S_{do} = \DO
\end{equation}
\begin{equation}
	S_{if} = \IF
\end{equation}

Дадим рекурсивное определение предикатов $H_0(R), \; k = 1, 2\ldots$:
\begin{equation}
	H_0(R) = R \wedge \neg (\exists j: 1 \leq j \leq n: B_j)
\end{equation}
\item Для любого $k > 0$:
\begin{equation}
	H_k(R) = wp(S_{if}, H_{k-1}(R)) \vee H_0(R)
\end{equation}

Тогда преобразователь предикатов для $S_{do}$ определяется как
\begin{equation}
	wp(S_{do}, R) = (\exists k: k \geq 0: H_k(R))
\end{equation}

Предикат $H_k(R)$ является слабейшим предусловием того, что оператор цикла $S_{do}$ завершится не более
чем за $k$ выборок.

Формула (2.17) означает предусловие, в котором должна находиться программа в случае, если все предохранители ложны.
В этом случае не производится вычисление ни одной охраняемой команды.

Формула (2.18) при $k>0$ имеет два дизъюнктивных слагаемых: либо все предохранители оказались ложны, и это произошло меньше чем за $k$ выборок,
либо есть истинные предохранители, и тогда выполняются действия, семантически эквивалентные однократному выполнению оператора $S_{if}$.
После этой выборки
программа должна оказаться в таком состоянии, чтобы далее потребовалось не более чем $k - 1$ выборка охраняемой команды для
завершения цикла в состоянии, удовлетворющем $R$.

Формальное определение семантики оператора цикла не имеет большого практического смысла, так как
заблаговременно определить количество итераций цикла $k$ представляется невозможным. 

\subsection{Инвариант цикла}
Если удается найти предикат, не изменяющий свою истинность после выполнения оператора $S_{if}$, и при этом
истинный до начала исполнения оператора $S_{do}$, более того достаточно сильный, чтобы
из него следовало постусловие цикла, то преобразователь предикатов для оператора цикла
можно определить гораздо проще, чем в формуле (2.19). Данные рассуждения следуют из \textit{основной теоремы для оператора цикла}.

\textbf{Теорема}. Пусть оператор цикла $S_{do}$ и предикат $P$ таковы, что предикат
\begin{equation}
	(P \wedge (\exists i: 1 \leq i \leq n: B_i)) \Rightarrow wp(S_{if}, P)
\end{equation}
справедлив для всех состояний. Тогда для оператора цикла $S_{do}$ предикат
\begin{equation}
	(P \wedge wp(S_{do}, T)) \Rightarrow wp(S_{do}, P \wedge \neg (\exsits i: 1 \leq i \leq n: B_j))
\end{equation}
где $T$ -- тавтология, также справедлив для всех состояний.

Предикат $w(S_{do}, T)$ характеризует начальные состояний, для которых оператор цикла завершает свою работу.
Основная теорема для оператора цикла позволяет считать предикат $P \wedge wp(S_{do}, T)$ предусловием цикла, если:
\begin{enumerate}
	\item Удается доказать, что цикл завершается. Другими словами, удается найти предикат $wp(S_{do}, T)$
	\item Предикат $P \wedge \neg (\exsits i: 1 \leq i \leq n: B_j)$ истинен для всех состояний
\end{enumerate}

\section{Макросы}
Многие алгоритмы удобно строить разбивая исходную задачу на подзадачи, а их, в свою очередь
на еще более мелкие подзадачи и так далее. Такой метод проектирования алгоритмов и программного
обеспечения носит название \textit{метода пошагового уточнения}. Для
того, чтобы использовать этот метод, удобным инструментом внутри языка являются макросы.

В настоящей реализации языка охраняемых команд введено понятие макросов с параметрами.
Такие макросы могут быть объявлены и определены отдельно от программы, а затем встроены в место ее вызова с 
заменой формальных параметров макроса, указанных в определении этого макроса на фактически предоставленные параметры при вызове. Макросы
являются синтаксическими и работают с абстрактным синтаксисом, а не исходным текстом.
Вызов макроса с параметрами является отдельным оператором языка. 

Например макрос, складывающий два числа $x$ и $y$ объявляется следующим образом:

\begin{verbatim}
add(x,y) :=
    z := x + y 
\end{verbatim}

Оператор вызова макроса:

\begin{verbatim}
x := 2; add(x, 2 * x)
\end{verbatim}

Программа будет иметь конечное состояние $x = 2; z = 6$

\section{Задание постусловий и инвариантов}
Поскольку исследуется вывод предусловия исходя из заданного пользователем постусловие, необходима
возможность его указывать либо вне программного текста, либо внутри него. Было решено
встроить постусловие и инварианты цикла в сам программный текст. Таким образом,
вместе с операторами программы, которые будут исполнены при интерпретации, содержится и
спецификация алгоритма в виде его постусловия и инвариантов. 

Постусловие объявляется как логическое выражение, содержащее переменные состояния программы. В этом случае программа
принимает вид:
\begin{verbatim}
	S1; S2; ...; Sn {<постусловие>}
\end{verbatim}

Каждый оператор цикла содержит свой инвариант, который также является логическим выражением:
\begin{verbatim}
	{<инвариант>} do ... od
\end{verbatim}

\section{Выводы} \label{ch2:conclusion}
Описаны операторы языка охраняемых команд и определена их семантика путем
сопоставления им некоторого преобразователя предикатов -- на множестве предикатов.
В приложении приведено описание конкретного синтаксиса языка в расширенной форме Бэкуса-Наура и иллюстрированы синтаксичекие диаграммы Вирта.
%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 1g