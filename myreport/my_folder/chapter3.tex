\chapter{Разработка интерпретатора и анализатора} \label{ch3}

\section{Генерация лексического и синтаксического анализатора}
Для разработки интерпретатора языка охраняемых команд дейкстры, необходимо разработать:
\begin{enumerate}
    \item лексический анализатор, разбивающий исходный набор символов программы на лексемы
    \item синтаксический анализатор, разбивающий полученный набор лексем на синтаксические единицы и строящий
    дерево разбора программы
    \item обход дерева разбора и выполнение необходимых семантических операций в его узлах
\end{enumerate}

Существует два подхода к разработке лексического и синтаксического анализатора: создание их вручную,
или автоматическая их генерация. При разработке интерпретатора языка охраняемых команд был выбран второй подход,
а в качестве инструмента для генерации анализаторов был использован ANTLR4.

Генератор ANTLR4 использует грамматику языка, заданную в специальном формате, похожем на РБНФ.
Грамматика ANTLR4 изложена в приложении П. 

\section{Интерпретация программы}
Интерпретация программы выполняется путем обхода ее дерева разбора. Корневой узел этого дерева
представляет из себя всю программу. Его дочерними узлами являются операторы, упорядоченные 
в порядке их нахождения в исходной программе.

Например, для программы $x := 2; y := 3; z := x + y$, 
дочерними узлами корневого узла являются три оператора присваивания.
Посещения узлов операторов имеют специфичные для них семантические операции. Далее изложены все семантические операции,
выполняемые для каждого типа оператора.

\subsection{Оператор присваивания}
Оператор присваивания содержит два важных дочерних узла: имя переменной, стоящее слева от знака присваивания,
и выражение, стоящее справа. Для вычисления выражений используется стек выражений, на который кладутся результаты
выполнения арифметических или логических операций, а снимаются с него перед выполнением арифметических или логических операций.
Выражение справа от знака присваивания вычисляется, и его значение оказывается на вершине стека.
Связь между именем переменной и ее значением сохраняется в отдельном словаре.

\subsection{Условный оператор}
Условный оператор содержит один или несколько узлов, соответствующих охраняемым командам.
Узел охраняемой команды, в свою очередь, содержит выражение-предохранитель, и список операторов,
охраняемых этим предохранителем.

При посещении узла условного оператора, поэтапно выполняются следующие шаги:
\begin{enumerate}
    \item Вычисляются логические значения предохранителей всех охраняемых команд, содержащихся в условном операторе.
    \item Если среди них не находится ни одного истинного значения, программа завершает свою работу,
    поскольку в этом случае условный оператор не завершается успешно.
    \item Среди охраняемых команд, чей предохранитель истинен, случайным образом выбирается одна из них. Случайность
    выбора получается путем генерирования псевдослучайного целого числа. 
    \item Вызывается процедура посещения узла списка операторов, соответствующего выбранной охраняемой команде.
\end{enumerate}

Таким образом, интерпретация недетерминированна с точностью до генерации псевдослучайного числа, однако
в случаях, когда охраняемая команда всего одна, или их несколько и они попарно исключают друг друга, 
условный оператор остается детерминированным.

\subsection{Оператор цикла}
Оператор цикла не отличается по своей синтаксической структуре от условного оператора, за 
исключением лексем do и od, обрамляющих охраняемые команды. При его посещении, поэтапно выполняются
следующие шаги:
\begin{enumerate}
    \item Вычисляются логические значения предохранителей всех охраняемых команд, содержащихся в условном операторе.
    \item Если среди них не находится ни одного истинного значения, посещение узла завершается. 
    \item Среди охраняемых команд, чей предохранитель истинен, случайным образом выбирается одна из них. Случайность
    выбора получается путем генерирования псевдослучайного целого числа. 
    \item Вызывается процедура посещения узла списка операторов, соответствующего выбранной охраняемой команде.
    \item Выполняется переход к шагу 1.
\end{enumerate}

\subsection{Оператор вызова макроса}
Узел оператор вызова макроса имеет следующие важные дочерние узлы: имя макроса и список аргументов, передаваемых макросу.
При посещении этого узла:
\begin{enumerate}
    \item Выполняется поиск списка операторов, соответствующего этому имени макроса. Такое соответствие сохраняется в словаре
    при объявлении макросов.
    \item Создается копия этого списка операторов и заменяются все вхождения формальных параметров макроса,
    указанных в его объявлении, на фактически переданные аргументы.
    \item Вызывается процедура посещения узла полученного списка операторов.
\end{enumerate}


\section{Вывод предусловия}
Для вывода предусловия используется тот же лексический и синтаксический анализатор,
что и для интерпретации программы. Однако семантические операции в узлах дерева разбора совершенно другие.

Вся программа состоит из списка операторов и заданного в конце программы желаемого постусловия. Это постусловие
необходимо задавать именно для обратного вывода, но совершенно не обязательно для интерпретации. Если
интерпретатор встретит постусловие в конце программы, он проверит истинность этого постусловия на полученном конечном состоянии программы.

Для обратного вывода необходимо посещать узлы операторов не в прямом порядке, а в обратном. Таким образом,
постусловие "протаскивается" от конца программы к началу, видоизменяясь при встрече с каждым оператором.
Далее описаны те семантические операции, которые выполняются при посещении каждого типа оператора.

\subsection{Оператор присваивания}
При посещении узла оператора присваивания $x := E$, совершаются следующие действия:
\begin{enumerate}
    \item Со стека предикатов снимается последний $R$
    \item В этом предикате все вхождения переменной $x$ заменяются на выражение $E$
    \item Полученный предикат $R'$ кладется обратно на стек
\end{enumerate}

\subsection{Условный оператор}
\newcommand{\IF}{\textbf{if } B_1 \rightarrow S_1 \text{ | } B_2 \rightarrow S_2 \text{ | } \ldots \text{ | } B_n \rightarrow S_n \textbf{ if}}
Для преобразования предиката через условный оператор
\begin{equation}
    \IF
\end{equation}
сначала со стека предикатов снимается послений $R$. Необходимо вычислить все предикаты $wp(S_i, R), 0\leq i\leq n$.
Для вычисления $wp(S_i, R)$:
\begin{enumerate}
    \item На стек кладется предикат $R$
    \item Вызывается процедура посещения узла $S_i$
    \item Со стека снимается предикат $wp(S_i, R)$
\end{enumerate}

После того, как все предикаты $wp(S_i, R), 0\leq i \leq n$ вычислены,
на стек кладется предикат 
\begin{equation}
    (B_1 \vee B_2 \vee \ldots \vee B_n) \wedge (B_1 \Rightarrow wp(S_1, R)) \wedge (B_2 \Rightarrow wp(S_2, R)) \wedge
    \ldots \wedge (B_n \Rightarrow wp(S_n, R))
\end{equation}

\subsection{Оператор цикла}
Для вывода предусловия каждый цикл программы должен быть снабжен своим инвариантом $P$.
При посещении узла оператора цикла, верхней на стеке предикат $R$ заменяется
на указанный инвариант. Однако, на инвариант наложено ограничение, обсужденное в главе 2.
Поэтому при выводе предусловия пользователю предлогается вывести самостоятельно формулу:
\begin{equation}
    $P \wedge \neg B_1 \neg B_2 \neg \ldots \neg B_n \Rightarrow R$
\end{equation}

Таким образом, вывод предусловия становится полуавтоматическим и требует ручного
вывода формул, которые не могут быть выведены автоматически в исчислении предикатов.
Такая ситуация возникает, например, когда в инварианте использованы функции,
свойства которых неизвестны при обратном выводе.

\subsection{Оператор вызова макроса}
Поскольку макросы работают на уровне синтаксиса языка, вызов макроса всего лишь
заменяется вызовом процедуры посещения узла списка операторов это макроса.

\subsection{Упрощение предикатов}
Изложенный способ трансформации предикатов, хоть и являяется удобным для машинной автоматизации,
совершенно не пригоден для чтения результируещего предусловия человеком. Дело в том, что с каждым условным оператором
или оператором цикла предикат достаточно сильно раздувается -- это видно из формулы ???. Поэтому необходимо
сокращать получающиеся предикаты, пользуясь правилами вывода исчисления предикатов.

Для упрощения предикатов используется система компьютерной алгебры в виде библиотеки sympy языка Python.
Для ее использования, при посещении узлов дерева разобра выражений используется специфические для sympy
объекты, тем самым строится объект выражения sympy. Такой объект может быть автоматически упрощен,
используя правила вывода пропозициональной логики.

\section{Функции в предикатах}
В постусловии программы, как и в инвариантах циклов, могут присутствовать вызовы функции с некоторым именем как
одна из альтернатив выражения. Например, следующая программа содержит функцию add внутри постусловия:
\begin{verbatim}
    z := x + y
    {z == add(x, y)}
\end{verbatim}

Очевидным образом будет выведено предусловие 
\begin{equation}
    x + y == add(x, y)
\end{equation}

Это равенство должно быть истинным для любых переменных состояния $x$ и $y$, однако поскольку заранее о свойствах функции
add ничего не известно, сократить предусловие в $True$ не удается. Данный механизм является мощным инструментом при 
формальной проверке корректности алгоритма, поскольку таким образом может быть введена произвольная функция
с неизвестными свойствами и указано постусловие, ее содержащие, а после вывода предусловия его необходимо рассмотреть,
опираясь на известные свойства введенной функции. Общезначимость полученного предусловия не обязательна, как в примере ???,
может быть получено некоторое ограничение на множество начальных состояний.

\section{Выводы} \label{ch3:conclusion}
Спроектирован и реализован язык охраняемых команд, содержащий основные конструкции структурного программирования
и при этом не является строго детерминированным. Для него реализован вспомогательный инструмент,
который позволяет в полуавтоматическом режиме строить семантику разработанной программы. Однако значительная часть
разработки алгоритма остается на плечах его создателя, потому что параллельно с написанием кода алгоритма необходимо:
\begin{enumerate}
    \item Указать постусловие, отражающее желаемый результат работы программы
    \item Для каждого цикла программы вычислить его инвариант
    \item Доказать, пользуясь свойствами введенных в предикаты функций, что из инвариантов циклов 
    следует их постусловие, а также упростить полученное предусловие аналогичным образом.
\end{enumerate}